



# import os
# import subprocess
# import keyboard
# import pyautogui
# import time
# import logging
# import tkinter as tk


# # Start STREAMING
# def startScreaming():
#     # Specify the folder where the .exe file is located and the file name
#     exe_file_path = "scrcpy-win64-v2.4//scrcpy.exe"

#     # Run .exe file for streaming
#     try:
#         process = subprocess.Popen(
#             [
#                 exe_file_path,
#                 "--prefer-text",
#                 "--turn-screen-off",
#                 "--stay-awake",
#             ],
#             stdout=subprocess.PIPE,
#             stderr=subprocess.PIPE,
#         )
#         print("Exe file executed successfully.")
#     except subprocess.CalledProcessError as e:
#         print(f"An error occurred while executing the exe file: {e}")

#     pyautogui.sleep(5)  # Wait for opening screen at 5 sec


# def get_click_position():
#     # Ana pencere oluşturma
#     root = tk.Tk()
#     root.attributes("-fullscreen", True)  # Tam ekran modunda çalışsın
#     root.attributes("-alpha", 0.3)  # Şeffaf pencere
#     root.config(cursor="none")  # Fare imlecini gizleyelim

#     # Crosshair oluşturma
#     crosshair_size = 20  # Nişangahın büyüklüğü
#     crosshair_color = "red"  # Nişangah rengi
#     canvas = tk.Canvas(
#         root, bg="white", highlightthickness=0
#     )  # Şeffaflık için bg beyaz olmalı
#     canvas.pack(fill=tk.BOTH, expand=True)

#     # Fare hareket ettikçe crosshair'in pozisyonunu güncelle
#     def move_crosshair(event):
#         canvas.delete("crosshair")  # Eski crosshair'i temizle
#         x, y = event.x, event.y
#         # Dikey çizgi
#         canvas.create_line(
#             x,
#             y - crosshair_size,
#             x,
#             y + crosshair_size,
#             fill=crosshair_color,
#             width=2,
#             tags="crosshair",
#         )
#         # Yatay çizgi
#         canvas.create_line(
#             x - crosshair_size,
#             y,
#             x + crosshair_size,
#             y,
#             fill=crosshair_color,
#             width=2,
#             tags="crosshair",
#         )

#     # Fare tıklamasıyla pozisyonu alma
#     def on_click(event):
#         x, y = pyautogui.position()  # Fare imlecinin pozisyonunu al
#         root.quit()  # Pencereyi kapat
#         root.destroy()  # Pencereyi yok et
#         return x, y

#     # Sol fare tuşuna basıldığında pozisyonu al
#     root.bind("<Button-1>", on_click)

#     # Fare hareketini yakala
#     root.bind("<Motion>", move_crosshair)

#     root.mainloop()

#     # Pozisyon döndürme
#     return pyautogui.position()


# def log_and_click(x, y):
#     try:
#         pyautogui.click(x, y)
#         logging.info(f"Başarıyla tıklandı: {x}, {y}")
#     except Exception as e:
#         logging.error(f"Tıklama işlemi başarısız: {e}")


# if __name__ == "__main__":
#     # Loglama sistemi (en başta tanımlanmalı)
#     logging.basicConfig(
#         level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
#     )

#     # Scrcpy başlat
#     startScreaming()

#     logging.info("Please click on the find button")
#     x_find_btn, y_find_btn = get_click_position()

#     time.sleep(1)
#     log_and_click(x_find_btn, y_find_btn)
#     time.sleep(1)
#     pyautogui.write("X empire bot", interval=0.1)
#     time.sleep(2)

#     # Botu bul ve tıkla
#     logging.info("Please click on the bot button")
#     x_bot_btn_1, y_bot_btn_1 = get_click_position()
#     time.sleep(1)
#     log_and_click(x_bot_btn_1, y_bot_btn_1)
#     time.sleep(1)


import tkinter as tk
from tkinter import ttk


class ActionChainBuilder(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Action Chain Builder")
        self.geometry("800x600")

        # Çerçeve: Yansıtılan ekran burada açılacak
        self.frame = tk.Frame(self, bg="black", width=400, height=600)
        self.frame.pack(side=tk.LEFT, padx=10, pady=10)

        # İşlem zinciri oluşturma alanı
        self.chain_frame = tk.Frame(self, bg="white", width=350, height=600)
        self.chain_frame.pack(side=tk.RIGHT, padx=10, pady=10)

        # İşlemleri tutacak liste
        self.action_list = []

        # Sürükle bırak işlemleri burada yapılacak
        self.create_action_buttons()

    def create_action_buttons(self):
        """İşlem butonlarını ve sürükle-bırak alanını oluşturur"""
        ttk.Label(self.chain_frame, text="Sürükle ve Bırak").pack(pady=10)

        # Örnek tıklama işlemi butonu
        click_button = ttk.Button(self.chain_frame, text="Tıklama İşlemi")
        click_button.pack(pady=5)
        click_button.bind("<Button-1>", self.add_click_action)

        # Örnek yazı yazma işlemi butonu
        type_button = ttk.Button(self.chain_frame, text="Yazı Yazma İşlemi")
        type_button.pack(pady=5)
        type_button.bind("<Button-1>", self.add_type_action)

    def add_click_action(self, event):
        """Tıklama işlemini işlem zincirine ekler"""
        self.action_list.append("Click")
        self.update_action_list()

    def add_type_action(self, event):
        """Yazı yazma işlemini işlem zincirine ekler"""
        self.action_list.append("Type")
        self.update_action_list()

    def update_action_list(self):
        """İşlem zincirini günceller ve arayüzde gösterir"""
        for widget in self.chain_frame.winfo_children():
            widget.destroy()

        for idx, action in enumerate(self.action_list):
            ttk.Label(self.chain_frame, text=f"{idx + 1}: {action}").pack(pady=5)

        self.create_action_buttons()


if __name__ == "__main__":
    app = ActionChainBuilder()
    app.mainloop()


-----------------------------------------------------------------------------------------
import sys
import os
import json
import pyautogui
import time
import cv2
import numpy as np
from PyQt5 import QtCore, QtGui, QtWidgets

# Scrcpy yolunu ayarlayın
scrcpy_exe_path = os.path.abspath("scrcpy-win64-v2.4\\scrcpy.exe")


class Operation:
    def __init__(self, op_type, name, **kwargs):
        self.type = op_type
        self.name = name
        self.params = kwargs


class App(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Kontrol Paneli")
        self.operations = []
        self.selected_operations = []
        self.init_ui()
        self.scrcpy_process = None
        self.start_scrcpy()

    def init_ui(self):
        main_layout = QtWidgets.QVBoxLayout(self)

        # Üst bölüm: İşlem ekleme
        upper_layout = QtWidgets.QVBoxLayout()
        op_buttons_layout = QtWidgets.QHBoxLayout()
        btn_add_click = QtWidgets.QPushButton("Add Click")
        btn_add_click.clicked.connect(self.add_click)
        btn_add_text = QtWidgets.QPushButton("Write Text")
        btn_add_text.clicked.connect(self.add_text)
        btn_add_wait = QtWidgets.QPushButton("Add Wait")
        btn_add_wait.clicked.connect(self.add_wait)
        btn_add_find = QtWidgets.QPushButton("Add Find")
        btn_add_find.clicked.connect(self.add_find)
        btn_save = QtWidgets.QPushButton("Save Automation")
        btn_save.clicked.connect(self.save_automation)
        btn_load = QtWidgets.QPushButton("Load Automation")
        btn_load.clicked.connect(self.load_automation)
        op_buttons_layout.addWidget(btn_add_click)
        op_buttons_layout.addWidget(btn_add_text)
        op_buttons_layout.addWidget(btn_add_wait)
        op_buttons_layout.addWidget(btn_add_find)
        op_buttons_layout.addWidget(btn_save)
        op_buttons_layout.addWidget(btn_load)
        upper_layout.addLayout(op_buttons_layout)

        # İşlem listesini göster
        self.op_list_widget = QtWidgets.QListWidget()
        upper_layout.addWidget(self.op_list_widget)

        # Alt bölüm: İşlemleri düzenleme
        lower_layout = QtWidgets.QVBoxLayout()
        lbl = QtWidgets.QLabel("Arrange Operations:")
        lower_layout.addWidget(lbl)
        self.selected_op_list_widget = QtWidgets.QListWidget()
        lower_layout.addWidget(self.selected_op_list_widget)
        arrange_buttons_layout = QtWidgets.QHBoxLayout()
        btn_add_to_sequence = QtWidgets.QPushButton("Add to Sequence")
        btn_add_to_sequence.clicked.connect(self.add_to_sequence)
        btn_remove_from_sequence = QtWidgets.QPushButton("Remove from Sequence")
        btn_remove_from_sequence.clicked.connect(self.remove_from_sequence)
        btn_run = QtWidgets.QPushButton("Run Automation")
        btn_run.clicked.connect(self.run_automation)
        arrange_buttons_layout.addWidget(btn_add_to_sequence)
        arrange_buttons_layout.addWidget(btn_remove_from_sequence)
        arrange_buttons_layout.addWidget(btn_run)
        lower_layout.addLayout(arrange_buttons_layout)

        main_layout.addLayout(upper_layout)
        main_layout.addLayout(lower_layout)

        self.resize(800, 600)
        self.show()

    def start_scrcpy(self):
        self.scrcpy_process = QtCore.QProcess(self)
        scrcpy_command = [
            scrcpy_exe_path,
            "--prefer-text",
            "--window-title=scrcpy",
            "--always-on-top",
        ]
        self.scrcpy_process.start(scrcpy_command[0], scrcpy_command[1:])
        self.scrcpy_process.started.connect(self.position_windows)
        self.scrcpy_process.errorOccurred.connect(self.handle_scrcpy_error)

    def position_windows(self):
        try:
            import pygetwindow as gw

            time.sleep(1)
            scrcpy_windows = gw.getWindowsWithTitle("scrcpy")
            if not scrcpy_windows:
                raise Exception("Scrcpy window not found")
            scrcpy_window = scrcpy_windows[0]
            screen = QtWidgets.QApplication.desktop().screenGeometry()
            scrcpy_width = 400
            scrcpy_height = 800
            total_width = scrcpy_width + self.width() + 20
            scrcpy_x = (screen.width() - total_width) // 2
            scrcpy_y = (screen.height() - scrcpy_height) // 2
            scrcpy_window.resizeTo(scrcpy_width, scrcpy_height)
            scrcpy_window.moveTo(scrcpy_x, scrcpy_y)
            app_x = scrcpy_x + scrcpy_width + 20
            app_y = scrcpy_y
            self.move(app_x, app_y)
        except Exception as e:
            print(f"Failed to position windows: {e}")

    def handle_scrcpy_error(self, error):
        QtWidgets.QMessageBox.critical(
            self, "Error", f"Failed to start scrcpy: {error}"
        )

    def add_click(self):
        try:
            import pygetwindow as gw

            scrcpy_windows = gw.getWindowsWithTitle("scrcpy")
            if not scrcpy_windows:
                raise Exception("Scrcpy window not found")
            scrcpy_window = scrcpy_windows[0]
            scrcpy_x = scrcpy_window.left
            scrcpy_y = scrcpy_window.top
            scrcpy_width = scrcpy_window.width
            scrcpy_height = scrcpy_window.height
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self, "Error", f"Scrcpy window not found: {e}"
            )
            return

        # Create overlay
        self.overlay = OverlayWidget(scrcpy_x, scrcpy_y, scrcpy_width, scrcpy_height)
        self.overlay.clicked.connect(self.on_click_position)
        self.overlay.show()

    def on_click_position(self, x, y):
        self.overlay.close()
        name, clicks, duration = self.get_click_details()
        if name:
            op = Operation("click", name, x=x, y=y, clicks=clicks, duration=duration)
            self.operations.append(op)
            self.op_list_widget.addItem(
                f"Click: {name} ({x}, {y}), Clicks: {clicks}, Duration: {duration}s"
            )

    def get_click_details(self):
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Click Details")
        dialog.setWindowModality(QtCore.Qt.WindowModal)
        layout = QtWidgets.QFormLayout(dialog)
        name_edit = QtWidgets.QLineEdit()
        clicks_edit = QtWidgets.QLineEdit("1")
        duration_edit = QtWidgets.QLineEdit("0")
        layout.addRow("Name:", name_edit)
        layout.addRow("Number of clicks:", clicks_edit)
        layout.addRow("Duration (seconds):", duration_edit)
        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            dialog,
        )
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        dialog.setGeometry(self.geometry().adjusted(50, 50, -50, -50))
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            name = name_edit.text()
            if not name:
                QtWidgets.QMessageBox.critical(dialog, "Error", "Name cannot be empty.")
                return None, None, None
            try:
                clicks = int(clicks_edit.text())
                duration = float(duration_edit.text())
            except ValueError:
                QtWidgets.QMessageBox.critical(
                    dialog, "Error", "Invalid number of clicks or duration."
                )
                return None, None, None
            return name, clicks, duration
        else:
            return None, None, None

    def add_text(self):
        title, text = self.get_text_details()
        if title:
            op = Operation("write", title, text=text)
            self.operations.append(op)
            self.op_list_widget.addItem(f"Write Text: {title} - {text}")

    def get_text_details(self):
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Write Text")
        dialog.setWindowModality(QtCore.Qt.WindowModal)
        layout = QtWidgets.QFormLayout(dialog)
        title_edit = QtWidgets.QLineEdit()
        text_edit = QtWidgets.QLineEdit()
        layout.addRow("Title:", title_edit)
        layout.addRow("Text:", text_edit)
        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            dialog,
        )
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        dialog.setGeometry(self.geometry().adjusted(50, 50, -50, -50))
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            title = title_edit.text()
            text = text_edit.text()
            if not title or not text:
                QtWidgets.QMessageBox.critical(
                    dialog, "Error", "Title and Text cannot be empty."
                )
                return None, None
            return title, text
        else:
            return None, None

    def add_wait(self):
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Wait")
        dialog.setWindowModality(QtCore.Qt.WindowModal)
        layout = QtWidgets.QFormLayout(dialog)
        name_edit = QtWidgets.QLineEdit()
        duration_edit = QtWidgets.QLineEdit()
        layout.addRow("Name:", name_edit)
        layout.addRow("Duration (seconds):", duration_edit)
        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            dialog,
        )
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        dialog.setGeometry(self.geometry().adjusted(50, 50, -50, -50))
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            name = name_edit.text()
            if not name:
                QtWidgets.QMessageBox.critical(dialog, "Error", "Name cannot be empty.")
                return
            try:
                duration = float(duration_edit.text())
                if duration < 0:
                    raise ValueError
            except ValueError:
                QtWidgets.QMessageBox.critical(dialog, "Error", "Invalid duration.")
                return
            op = Operation("wait", name, duration=duration)
            self.operations.append(op)
            self.op_list_widget.addItem(f"Wait: {name}, Duration: {duration}s")

    def add_find(self):
        try:
            import pygetwindow as gw

            scrcpy_windows = gw.getWindowsWithTitle("scrcpy")
            if not scrcpy_windows:
                raise Exception("Scrcpy window not found")
            scrcpy_window = scrcpy_windows[0]
            scrcpy_x = scrcpy_window.left
            scrcpy_y = scrcpy_window.top
            scrcpy_width = scrcpy_window.width
            scrcpy_height = scrcpy_window.height
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self, "Error", f"Scrcpy window not found: {e}"
            )
            return

        # Seçim için overlay oluştur
        self.overlay = SelectionOverlay(scrcpy_x, scrcpy_y, scrcpy_width, scrcpy_height)
        self.overlay.selection_made.connect(self.on_selection_made)
        self.overlay.show()

    def on_selection_made(self, x, y, w, h, screenshot):
        self.overlay.close()
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Find Details")
        dialog.setWindowModality(QtCore.Qt.WindowModal)
        layout = QtWidgets.QFormLayout(dialog)
        name_edit = QtWidgets.QLineEdit()
        layout.addRow("Name:", name_edit)
        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            dialog,
        )
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        dialog.setGeometry(self.geometry().adjusted(50, 50, -50, -50))
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            name = name_edit.text()
            if not name:
                QtWidgets.QMessageBox.critical(dialog, "Error", "Name cannot be empty.")
                return
            template_path = f"templates/{name}.png"
            if not os.path.exists("templates"):
                os.makedirs("templates")
            cv2.imwrite(template_path, screenshot)
            op = Operation("find", name, template=template_path)
            self.operations.append(op)
            self.op_list_widget.addItem(f"Find: {name}")
        else:
            return

    def add_to_sequence(self):
        selected_items = self.op_list_widget.selectedItems()
        for item in selected_items:
            index = self.op_list_widget.row(item)
            op = self.operations[index]
            self.selected_operations.append(op)
            self.selected_op_list_widget.addItem(item.text())

    def remove_from_sequence(self):
        selected_items = self.selected_op_list_widget.selectedItems()
        for item in selected_items:
            index = self.selected_op_list_widget.row(item)
            self.selected_operations.pop(index)
            self.selected_op_list_widget.takeItem(index)

    def run_automation(self):
        try:
            import pygetwindow as gw

            scrcpy_windows = gw.getWindowsWithTitle("scrcpy")
            if not scrcpy_windows:
                raise Exception("Scrcpy window not found")
            scrcpy_window = scrcpy_windows[0]
            scrcpy_x = scrcpy_window.left
            scrcpy_y = scrcpy_window.top
            scrcpy_width = scrcpy_window.width
            scrcpy_height = scrcpy_window.height
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self, "Error", f"Scrcpy window not found: {e}"
            )
            return

        for op in self.selected_operations:
            if op.type == "click":
                # Tıklama işlemi
                x, y = op.params["x"], op.params["y"]
                clicks = op.params.get("clicks", 1)
                duration = op.params.get("duration", 0)
                interval = duration / clicks if clicks > 0 else duration
                pyautogui.click(
                    x=scrcpy_x + x,
                    y=scrcpy_y + y,
                    clicks=clicks,
                    interval=interval,
                )
                time.sleep(0.5)
            elif op.type == "write":
                # Yazı yazma işlemi
                text = op.params["text"]
                scrcpy_window.activate()
                time.sleep(0.1)
                pyautogui.click(scrcpy_x + 10, scrcpy_y + 10)
                time.sleep(0.1)
                pyautogui.typewrite(text, interval=0.1)
                time.sleep(0.5)
            elif op.type == "wait":
                # Bekleme işlemi
                duration = op.params["duration"]
                time.sleep(duration)
            elif op.type == "find":
                # Bulma işlemi
                template_path = op.params["template"]
                if not os.path.exists(template_path):
                    QtWidgets.QMessageBox.critical(
                        self, "Error", f"Template image not found: {template_path}"
                    )
                    continue
                screenshot = pyautogui.screenshot(
                    region=(scrcpy_x, scrcpy_y, scrcpy_width, scrcpy_height)
                )
                screenshot = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
                template = cv2.imread(template_path)
                res = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)
                threshold = 0.8
                loc = np.where(res >= threshold)
                if len(loc[0]) > 0:
                    pt = (loc[1][0], loc[0][0])
                    pyautogui.click(
                        scrcpy_x + pt[0] + template.shape[1] // 2,
                        scrcpy_y + pt[1] + template.shape[0] // 2,
                    )
                else:
                    QtWidgets.QMessageBox.warning(
                        self, "Warning", f"Template {op.name} not found on screen."
                    )

    def save_automation(self):
        title, ok = QtWidgets.QInputDialog.getText(self, "Save Automation", "Title:")
        if ok and title:
            options = QtWidgets.QFileDialog.Options()
            filename, _ = QtWidgets.QFileDialog.getSaveFileName(
                self,
                "Save Automation",
                title + ".json",
                "JSON Files (*.json)",
                options=options,
            )
            if filename:
                data = [op.__dict__ for op in self.selected_operations]
                with open(filename, "w") as f:
                    json.dump(data, f)
                QtWidgets.QMessageBox.information(
                    self, "Success", "Automation saved successfully."
                )

    def load_automation(self):
        options = QtWidgets.QFileDialog.Options()
        filename, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "Load Automation", "", "JSON Files (*.json)", options=options
        )
        if filename:
            with open(filename, "r") as f:
                data = json.load(f)
            self.selected_operations = []
            self.selected_op_list_widget.clear()
            for op_data in data:
                op = Operation(op_data["type"], op_data["name"], **op_data["params"])
                self.selected_operations.append(op)
                if op.type == "click":
                    self.selected_op_list_widget.addItem(
                        f"Click: {op.name} ({op.params['x']}, {op.params['y']}), Clicks: {op.params['clicks']}, Duration: {op.params['duration']}s"
                    )
                elif op.type == "write":
                    self.selected_op_list_widget.addItem(
                        f"Write Text: {op.name} - {op.params['text']}"
                    )

    def closeEvent(self, event):
        if self.scrcpy_process:
            self.scrcpy_process.kill()
            self.scrcpy_process.waitForFinished()
        event.accept()


class OverlayWidget(QtWidgets.QWidget):
    clicked = QtCore.pyqtSignal(int, int)

    def __init__(self, x, y, width, height):
        super().__init__(None)
        self.setWindowFlags(
            QtCore.Qt.WindowStaysOnTopHint | QtCore.Qt.FramelessWindowHint
        )
        self.setAttribute(QtCore.Qt.WA_TransparentForMouseEvents, False)
        self.setWindowOpacity(0.3)
        self.setGeometry(x, y, width, height)
        self.setCursor(QtCore.Qt.BlankCursor)
        self.crosshair_size = 20
        self.crosshair_color = QtGui.QColor("red")
        self.setMouseTracking(True)
        self.cursor_pos = QtCore.QPoint(width // 2, height // 2)

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setPen(QtGui.QPen(self.crosshair_color, 2))
        x = self.cursor_pos.x()
        y = self.cursor_pos.y()
        painter.drawLine(x - self.crosshair_size, y, x + self.crosshair_size, y)
        painter.drawLine(x, y - self.crosshair_size, x, y + self.crosshair_size)

    def mouseMoveEvent(self, event):
        self.cursor_pos = event.pos()
        self.update()

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            self.clicked.emit(event.x(), event.y())


class SelectionOverlay(QtWidgets.QWidget):
    selection_made = QtCore.pyqtSignal(int, int, int, int, np.ndarray)

    def __init__(self, x, y, width, height):
        super().__init__(None)
        self.setWindowFlags(
            QtCore.Qt.WindowStaysOnTopHint | QtCore.Qt.FramelessWindowHint
        )
        self.setAttribute(QtCore.Qt.WA_TransparentForMouseEvents, False)
        self.setWindowOpacity(0.3)
        self.setGeometry(x, y, width, height)
        self.setCursor(QtCore.Qt.CrossCursor)
        self.start_pos = None
        self.end_pos = None
        self.rect = None

    def mousePressEvent(self, event):
        self.start_pos = event.pos()
        self.rect = QtCore.QRect()

    def mouseMoveEvent(self, event):
        self.end_pos = event.pos()
        self.rect = QtCore.QRect(self.start_pos, self.end_pos)
        self.update()

    def mouseReleaseEvent(self, event):
        self.end_pos = event.pos()
        self.rect = QtCore.QRect(self.start_pos, self.end_pos)
        x = self.rect.left()
        y = self.rect.top()
        w = self.rect.width()
        h = self.rect.height()
        if w > 0 and h > 0:
            screenshot = pyautogui.screenshot(region=(self.x() + x, self.y() + y, w, h))
            screenshot = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
            self.selection_made.emit(x, y, w, h, screenshot)
        self.close()

    def paintEvent(self, event):
        if self.rect:
            painter = QtGui.QPainter(self)
            painter.setPen(QtGui.QPen(QtGui.QColor("red"), 2))
            painter.drawRect(self.rect.normalized())


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    ex = App()
    sys.exit(app.exec_())






--------------------------------------------------------------------------------------------------


import sys
import os
import json
import pyautogui
import time
import cv2
import numpy as np
from PyQt5 import QtCore, QtGui, QtWidgets

# Scrcpy yolunu ayarlayın
scrcpy_exe_path = os.path.abspath("scrcpy-win64-v2.4\\scrcpy.exe")


class Operation:
    def __init__(self, op_type, name, **kwargs):
        self.type = op_type
        self.name = name
        self.params = kwargs


class App(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Kontrol Paneli")
        self.operations = []
        self.selected_operations = []
        self.init_ui()
        self.scrcpy_process = None
        self.start_scrcpy()

    def init_ui(self):
        main_layout = QtWidgets.QVBoxLayout(self)

        # Üst bölüm: İşlem ekleme
        upper_layout = QtWidgets.QVBoxLayout()
        op_buttons_layout = QtWidgets.QHBoxLayout()
        btn_add_click = QtWidgets.QPushButton("Add Click")
        btn_add_click.clicked.connect(self.add_click)
        btn_add_text = QtWidgets.QPushButton("Write Text")
        btn_add_text.clicked.connect(self.add_text)
        btn_add_wait = QtWidgets.QPushButton("Add Wait")
        btn_add_wait.clicked.connect(self.add_wait)
        btn_add_find = QtWidgets.QPushButton("Add Find")
        btn_add_find.clicked.connect(self.add_find)
        btn_add_if = QtWidgets.QPushButton("Add If")
        btn_add_if.clicked.connect(self.add_if)
        btn_add_else = QtWidgets.QPushButton("Add Else")
        btn_add_else.clicked.connect(self.add_else)
        btn_add_endif = QtWidgets.QPushButton("Add End If")
        btn_add_endif.clicked.connect(self.add_endif)
        btn_save = QtWidgets.QPushButton("Save Automation")
        btn_save.clicked.connect(self.save_automation)
        btn_load = QtWidgets.QPushButton("Load Automation")
        btn_load.clicked.connect(self.load_automation)
        op_buttons_layout.addWidget(btn_add_click)
        op_buttons_layout.addWidget(btn_add_text)
        op_buttons_layout.addWidget(btn_add_wait)
        op_buttons_layout.addWidget(btn_add_find)
        op_buttons_layout.addWidget(btn_add_if)
        op_buttons_layout.addWidget(btn_add_else)
        op_buttons_layout.addWidget(btn_add_endif)
        op_buttons_layout.addWidget(btn_save)
        op_buttons_layout.addWidget(btn_load)
        upper_layout.addLayout(op_buttons_layout)

        # İşlem listesini göster
        self.op_list_widget = QtWidgets.QListWidget()
        upper_layout.addWidget(self.op_list_widget)

        # Alt bölüm: İşlemleri düzenleme
        lower_layout = QtWidgets.QVBoxLayout()
        lbl = QtWidgets.QLabel("Arrange Operations:")
        lower_layout.addWidget(lbl)
        self.selected_op_list_widget = QtWidgets.QListWidget()
        lower_layout.addWidget(self.selected_op_list_widget)
        arrange_buttons_layout = QtWidgets.QHBoxLayout()
        btn_add_to_sequence = QtWidgets.QPushButton("Add to Sequence")
        btn_add_to_sequence.clicked.connect(self.add_to_sequence)
        btn_remove_from_sequence = QtWidgets.QPushButton("Remove from Sequence")
        btn_remove_from_sequence.clicked.connect(self.remove_from_sequence)
        btn_run = QtWidgets.QPushButton("Run Automation")
        btn_run.clicked.connect(self.run_automation)
        arrange_buttons_layout.addWidget(btn_add_to_sequence)
        arrange_buttons_layout.addWidget(btn_remove_from_sequence)
        arrange_buttons_layout.addWidget(btn_run)
        lower_layout.addLayout(arrange_buttons_layout)

        main_layout.addLayout(upper_layout)
        main_layout.addLayout(lower_layout)

        self.resize(800, 600)
        self.show()

    def start_scrcpy(self):
        self.scrcpy_process = QtCore.QProcess(self)
        scrcpy_command = [
            scrcpy_exe_path,
            "--prefer-text",
            "--window-title=scrcpy",
            "--always-on-top",
        ]
        self.scrcpy_process.start(scrcpy_command[0], scrcpy_command[1:])
        self.scrcpy_process.started.connect(self.position_windows)
        self.scrcpy_process.errorOccurred.connect(self.handle_scrcpy_error)

    def position_windows(self):
        try:
            import pygetwindow as gw

            time.sleep(1)
            scrcpy_windows = gw.getWindowsWithTitle("scrcpy")
            if not scrcpy_windows:
                raise Exception("Scrcpy window not found")
            scrcpy_window = scrcpy_windows[0]
            screen = QtWidgets.QApplication.desktop().screenGeometry()
            scrcpy_width = 400
            scrcpy_height = 800
            total_width = scrcpy_width + self.width() + 20
            scrcpy_x = (screen.width() - total_width) // 2
            scrcpy_y = (screen.height() - scrcpy_height) // 2
            scrcpy_window.resizeTo(scrcpy_width, scrcpy_height)
            scrcpy_window.moveTo(scrcpy_x, scrcpy_y)
            app_x = scrcpy_x + scrcpy_width + 20
            app_y = scrcpy_y
            self.move(app_x, app_y)
        except Exception as e:
            print(f"Failed to position windows: {e}")

    def handle_scrcpy_error(self, error):
        QtWidgets.QMessageBox.critical(
            self, "Error", f"Failed to start scrcpy: {error}"
        )

    def add_click(self):
        try:
            import pygetwindow as gw

            scrcpy_windows = gw.getWindowsWithTitle("scrcpy")
            if not scrcpy_windows:
                raise Exception("Scrcpy window not found")
            scrcpy_window = scrcpy_windows[0]
            scrcpy_x = scrcpy_window.left
            scrcpy_y = scrcpy_window.top
            scrcpy_width = scrcpy_window.width
            scrcpy_height = scrcpy_window.height
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self, "Error", f"Scrcpy window not found: {e}"
            )
            return

        # Create overlay
        self.overlay = OverlayWidget(scrcpy_x, scrcpy_y, scrcpy_width, scrcpy_height)
        self.overlay.clicked.connect(self.on_click_position)
        self.overlay.show()

    def on_click_position(self, x, y):
        self.overlay.close()
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Click Details")
        dialog.setWindowModality(QtCore.Qt.WindowModal)
        layout = QtWidgets.QFormLayout(dialog)
        name_edit = QtWidgets.QLineEdit()
        # Radio buttons for choosing between number of clicks and duration
        click_option_group = QtWidgets.QButtonGroup(dialog)
        clicks_radio = QtWidgets.QRadioButton("Number of clicks")
        duration_radio = QtWidgets.QRadioButton("Duration (seconds)")
        clicks_radio.setChecked(True)
        click_option_group.addButton(clicks_radio)
        click_option_group.addButton(duration_radio)
        clicks_edit = QtWidgets.QLineEdit("1")
        duration_edit = QtWidgets.QLineEdit("0")
        interval_edit = QtWidgets.QLineEdit("100")  # Default interval in milliseconds
        layout.addRow("Name:", name_edit)
        layout.addRow(clicks_radio, clicks_edit)
        layout.addRow(duration_radio, duration_edit)
        layout.addRow("Interval between clicks (ms):", interval_edit)
        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            dialog,
        )
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        dialog.setGeometry(self.geometry().adjusted(50, 50, -50, -50))
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            name = name_edit.text()
            if not name:
                QtWidgets.QMessageBox.critical(dialog, "Error", "Name cannot be empty.")
                return
            interval = int(interval_edit.text())
            if clicks_radio.isChecked():
                try:
                    clicks = int(clicks_edit.text())
                    if clicks < 1:
                        raise ValueError
                    op = Operation(
                        "click", name, x=x, y=y, clicks=clicks, interval=interval
                    )
                except ValueError:
                    QtWidgets.QMessageBox.critical(
                        dialog, "Error", "Invalid number of clicks."
                    )
                    return
            elif duration_radio.isChecked():
                try:
                    duration = float(duration_edit.text())
                    if duration <= 0:
                        raise ValueError
                    op = Operation(
                        "click", name, x=x, y=y, duration=duration, interval=interval
                    )
                except ValueError:
                    QtWidgets.QMessageBox.critical(dialog, "Error", "Invalid duration.")
                    return
            else:
                QtWidgets.QMessageBox.critical(
                    dialog, "Error", "Please select an option."
                )
                return
            self.operations.append(op)
            self.op_list_widget.addItem(f"Click: {name} at ({x}, {y})")
        else:
            return

    def add_text(self):
        # title, text = self.get_text_details()
        # if title:
        #     op = Operation("write", title, text=text)
        #     self.operations.append(op)
        #     self.op_list_widget.addItem(f"Write Text: {title} - {text}")

        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Write Text")
        dialog.setWindowModality(QtCore.Qt.WindowModal)
        layout = QtWidgets.QFormLayout(dialog)
        title_edit = QtWidgets.QLineEdit()
        text_edit = QtWidgets.QLineEdit()
        layout.addRow("Title:", title_edit)
        layout.addRow("Text:", text_edit)
        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            dialog,
        )
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        dialog.setGeometry(self.geometry().adjusted(50, 50, -50, -50))
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            title = title_edit.text()
            text = text_edit.text()
            if not title or not text:
                QtWidgets.QMessageBox.critical(
                    dialog, "Error", "Title and Text cannot be empty."
                )
                return
            op = Operation("write", title, text=text)
            self.operations.append(op)
            self.op_list_widget.addItem(f"Write Text: {title} - {text}")
        else:
            return

    def add_wait(self):

        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Wait")
        dialog.setWindowModality(QtCore.Qt.WindowModal)
        layout = QtWidgets.QFormLayout(dialog)
        name_edit = QtWidgets.QLineEdit()
        duration_edit = QtWidgets.QLineEdit()
        layout.addRow("Name:", name_edit)
        layout.addRow("Duration (seconds):", duration_edit)
        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            dialog,
        )
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        dialog.setGeometry(self.geometry().adjusted(50, 50, -50, -50))
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            name = name_edit.text()
            if not name:
                QtWidgets.QMessageBox.critical(dialog, "Error", "Name cannot be empty.")
                return
            try:
                duration = float(duration_edit.text())
                if duration < 0:
                    raise ValueError
            except ValueError:
                QtWidgets.QMessageBox.critical(dialog, "Error", "Invalid duration.")
                return
            op = Operation("wait", name, duration=duration)
            self.operations.append(op)
            self.op_list_widget.addItem(f"Wait: {name}, Duration: {duration}s")
        else:
            return

    def add_find(self):
        try:
            import pygetwindow as gw

            scrcpy_windows = gw.getWindowsWithTitle("scrcpy")
            if not scrcpy_windows:
                raise Exception("Scrcpy window not found")
            scrcpy_window = scrcpy_windows[0]
            scrcpy_x = scrcpy_window.left
            scrcpy_y = scrcpy_window.top
            scrcpy_width = scrcpy_window.width
            scrcpy_height = scrcpy_window.height
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self, "Error", f"Scrcpy window not found: {e}"
            )
            return

        # Seçim için overlay oluştur
        self.overlay = SelectionOverlay(scrcpy_x, scrcpy_y, scrcpy_width, scrcpy_height)
        self.overlay.selection_made.connect(self.on_selection_made)
        self.overlay.show()

    def on_selection_made(self, x, y, w, h, screenshot):
        self.overlay.close()
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Find Details")
        dialog.setWindowModality(QtCore.Qt.WindowModal)
        layout = QtWidgets.QFormLayout(dialog)
        name_edit = QtWidgets.QLineEdit()
        layout.addRow("Name:", name_edit)
        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            dialog,
        )
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        dialog.setGeometry(self.geometry().adjusted(50, 50, -50, -50))
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            name = name_edit.text()
            if not name:
                QtWidgets.QMessageBox.critical(dialog, "Error", "Name cannot be empty.")
                return
            template_path = f"templates/{name}.png"
            if not os.path.exists("templates"):
                os.makedirs("templates")
            cv2.imwrite(template_path, screenshot)
            op = Operation("find", name, template=template_path)
            self.operations.append(op)
            self.op_list_widget.addItem(f"Find: {name}")
        else:
            return

    def add_if(self):
        op = Operation("if", "If")
        self.selected_operations.append(op)
        self.selected_op_list_widget.addItem("If")

    def add_else(self):
        op = Operation("else", "Else")
        self.selected_operations.append(op)
        self.selected_op_list_widget.addItem("Else")

    def add_endif(self):
        op = Operation("endif", "End If")
        self.selected_operations.append(op)
        self.selected_op_list_widget.addItem("End If")

    def add_to_sequence(self):
        selected_items = self.op_list_widget.selectedItems()
        for item in selected_items:
            index = self.op_list_widget.row(item)
            op = self.operations[index]
            self.selected_operations.append(op)
            self.selected_op_list_widget.addItem(item.text())

    def remove_from_sequence(self):
        selected_items = self.selected_op_list_widget.selectedItems()
        for item in selected_items:
            index = self.selected_op_list_widget.row(item)
            self.selected_operations.pop(index)
            self.selected_op_list_widget.takeItem(index)

    def run_automation(self):
        try:
            import pygetwindow as gw

            scrcpy_windows = gw.getWindowsWithTitle("scrcpy")
            if not scrcpy_windows:
                raise Exception("Scrcpy window not found")
            scrcpy_window = scrcpy_windows[0]
            scrcpy_x = scrcpy_window.left
            scrcpy_y = scrcpy_window.top
            scrcpy_width = scrcpy_window.width
            scrcpy_height = scrcpy_window.height
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self, "Error", f"Scrcpy window not found: {e}"
            )
            return

        skip_block = False
        i = 0
        while i < len(self.selected_operations):
            op = self.selected_operations[i]
            if op.type == "if":
                condition_result = None
                # Bir önceki 'find' işleminin sonucunu kontrol ediyoruz
                if i > 0 and self.selected_operations[i - 1].type == "find":
                    condition_result = self.selected_operations[i - 1].params.get(
                        "found", False
                    )
                else:
                    QtWidgets.QMessageBox.critical(
                        self, "Error", "'If' must follow a 'Find' operation."
                    )
                    return
                if not condition_result:
                    # Koşul sağlanmadı, 'else' veya 'endif' e kadar atla
                    skip_block = True
                i += 1
                continue
            elif op.type == "else":
                skip_block = not skip_block
                i += 1
                continue
            elif op.type == "endif":
                skip_block = False
                i += 1
                continue

            if skip_block:
                i += 1
                continue

            if op.type == "click":
                x, y = op.params["x"], op.params["y"]
                interval = op.params.get("interval", 100) / 1000.0  # Convert ms to s
                if "clicks" in op.params:
                    clicks = op.params["clicks"]
                    for _ in range(clicks):
                        pyautogui.click(x=scrcpy_x + x, y=scrcpy_y + y)
                        time.sleep(interval)
                elif "duration" in op.params:
                    end_time = time.time() + op.params["duration"]
                    while time.time() < end_time:
                        pyautogui.click(x=scrcpy_x + x, y=scrcpy_y + y)
                        time.sleep(interval)
                time.sleep(0.5)
            elif op.type == "write":
                text = op.params["text"]
                scrcpy_window.activate()
                time.sleep(0.1)
                pyautogui.click(scrcpy_x + 10, scrcpy_y + 10)
                time.sleep(0.1)
                pyautogui.typewrite(text, interval=0.1)
                time.sleep(0.5)
            elif op.type == "wait":
                duration = op.params["duration"]
                time.sleep(duration)
            elif op.type == "find":
                template_path = op.params["template"]
                if not os.path.exists(template_path):
                    QtWidgets.QMessageBox.critical(
                        self, "Error", f"Template image not found: {template_path}"
                    )
                    return
                screenshot = pyautogui.screenshot(
                    region=(scrcpy_x, scrcpy_y, scrcpy_width, scrcpy_height)
                )
                screenshot = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
                template = cv2.imread(template_path)
                res = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)
                threshold = 0.8
                loc = np.where(res >= threshold)
                if len(loc[0]) > 0:
                    pt = (loc[1][0], loc[0][0])
                    pyautogui.click(
                        scrcpy_x + pt[0] + template.shape[1] // 2,
                        scrcpy_y + pt[1] + template.shape[0] // 2,
                    )
                    op.params["found"] = True
                else:
                    op.params["found"] = False
            i += 1

    def save_automation(self):
        title, ok = QtWidgets.QInputDialog.getText(self, "Save Automation", "Title:")
        if ok and title:
            options = QtWidgets.QFileDialog.Options()
            filename, _ = QtWidgets.QFileDialog.getSaveFileName(
                self,
                "Save Automation",
                title + ".json",
                "JSON Files (*.json)",
                options=options,
            )
            if filename:
                data = [op.__dict__ for op in self.selected_operations]
                with open(filename, "w") as f:
                    json.dump(data, f)
                QtWidgets.QMessageBox.information(
                    self, "Success", "Automation saved successfully."
                )

    def load_automation(self):
        options = QtWidgets.QFileDialog.Options()
        filename, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "Load Automation", "", "JSON Files (*.json)", options=options
        )
        if filename:
            with open(filename, "r") as f:
                data = json.load(f)
            self.selected_operations = []
            self.selected_op_list_widget.clear()
            for op_data in data:
                op = Operation(op_data["type"], op_data["name"], **op_data["params"])
                self.selected_operations.append(op)
                if op.type == "click":
                    self.selected_op_list_widget.addItem(f"Click: {op.name}")
                elif op.type == "write":
                    self.selected_op_list_widget.addItem(f"Write Text: {op.name}")
                elif op.type == "wait":
                    self.selected_op_list_widget.addItem(f"Wait: {op.name}")
                elif op.type == "find":
                    self.selected_op_list_widget.addItem(f"Find: {op.name}")
                elif op.type == "if":
                    self.selected_op_list_widget.addItem("If")
                elif op.type == "else":
                    self.selected_op_list_widget.addItem("Else")
                elif op.type == "endif":
                    self.selected_op_list_widget.addItem("End If")

    def closeEvent(self, event):
        if self.scrcpy_process:
            self.scrcpy_process.kill()
            self.scrcpy_process.waitForFinished()
        event.accept()


class OverlayWidget(QtWidgets.QWidget):
    clicked = QtCore.pyqtSignal(int, int)

    def __init__(self, x, y, width, height):
        super().__init__(None)
        self.setWindowFlags(
            QtCore.Qt.WindowStaysOnTopHint | QtCore.Qt.FramelessWindowHint
        )
        self.setAttribute(QtCore.Qt.WA_TransparentForMouseEvents, False)
        self.setWindowOpacity(0.3)
        self.setGeometry(x, y, width, height)
        self.setCursor(QtCore.Qt.BlankCursor)
        self.crosshair_size = 20
        self.crosshair_color = QtGui.QColor("red")
        self.setMouseTracking(True)
        self.cursor_pos = QtCore.QPoint(width // 2, height // 2)

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setPen(QtGui.QPen(self.crosshair_color, 2))
        x = self.cursor_pos.x()
        y = self.cursor_pos.y()
        painter.drawLine(x - self.crosshair_size, y, x + self.crosshair_size, y)
        painter.drawLine(x, y - self.crosshair_size, x, y + self.crosshair_size)

    def mouseMoveEvent(self, event):
        self.cursor_pos = event.pos()
        self.update()

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            self.clicked.emit(event.x(), event.y())


class SelectionOverlay(QtWidgets.QWidget):
    selection_made = QtCore.pyqtSignal(int, int, int, int, np.ndarray)

    def __init__(self, x, y, width, height):
        super().__init__(None)
        self.setWindowFlags(
            QtCore.Qt.WindowStaysOnTopHint | QtCore.Qt.FramelessWindowHint
        )
        self.setAttribute(QtCore.Qt.WA_TransparentForMouseEvents, False)
        self.setWindowOpacity(0.3)
        self.setGeometry(x, y, width, height)
        self.setCursor(QtCore.Qt.CrossCursor)
        self.start_pos = None
        self.end_pos = None
        self.rect = None

    def mousePressEvent(self, event):
        self.start_pos = event.pos()
        self.rect = QtCore.QRect()

    def mouseMoveEvent(self, event):
        self.end_pos = event.pos()
        self.rect = QtCore.QRect(self.start_pos, self.end_pos)
        self.update()

    def mouseReleaseEvent(self, event):
        self.end_pos = event.pos()
        self.rect = QtCore.QRect(self.start_pos, self.end_pos)
        x = self.rect.left()
        y = self.rect.top()
        w = self.rect.width()
        h = self.rect.height()
        if w > 0 and h > 0:
            screenshot = pyautogui.screenshot(region=(self.x() + x, self.y() + y, w, h))
            screenshot = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
            self.selection_made.emit(x, y, w, h, screenshot)
        self.close()

    def paintEvent(self, event):
        if self.rect:
            painter = QtGui.QPainter(self)
            painter.setPen(QtGui.QPen(QtGui.QColor("red"), 2))
            painter.drawRect(self.rect.normalized())


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    ex = App()
    sys.exit(app.exec_())
