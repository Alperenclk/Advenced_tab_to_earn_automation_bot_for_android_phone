import sys
import os
import json
import pyautogui
import time
import cv2
import numpy as np
from PyQt5 import QtCore, QtGui, QtWidgets

# Scrcpy yolunu ayarlayın
scrcpy_exe_path = os.path.abspath("scrcpy-win64-v2.4\\scrcpy.exe")


class Operation:
    def __init__(self, op_type, name, **kwargs):
        self.type = op_type
        self.name = name
        self.params = kwargs


class App(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Kontrol Paneli")
        self.operations = []
        self.selected_operations = []
        self.init_ui()
        self.scrcpy_process = None
        self.start_scrcpy()

    def init_ui(self):
        main_layout = QtWidgets.QVBoxLayout(self)

        # Üst bölüm: İşlem ekleme
        upper_layout = QtWidgets.QVBoxLayout()
        op_buttons_layout = QtWidgets.QHBoxLayout()
        btn_add_click = QtWidgets.QPushButton("Add Click")
        btn_add_click.clicked.connect(self.add_click)
        btn_add_text = QtWidgets.QPushButton("Write Text")
        btn_add_text.clicked.connect(self.add_text)
        btn_add_wait = QtWidgets.QPushButton("Add Wait")
        btn_add_wait.clicked.connect(self.add_wait)
        btn_add_find = QtWidgets.QPushButton("Add Find")
        btn_add_find.clicked.connect(self.add_find)
        btn_save = QtWidgets.QPushButton("Save Automation")
        btn_save.clicked.connect(self.save_automation)
        btn_load = QtWidgets.QPushButton("Load Automation")
        btn_load.clicked.connect(self.load_automation)
        op_buttons_layout.addWidget(btn_add_click)
        op_buttons_layout.addWidget(btn_add_text)
        op_buttons_layout.addWidget(btn_add_wait)
        op_buttons_layout.addWidget(btn_add_find)
        op_buttons_layout.addWidget(btn_save)
        op_buttons_layout.addWidget(btn_load)
        upper_layout.addLayout(op_buttons_layout)

        # İşlem listesini göster
        self.op_list_widget = QtWidgets.QListWidget()
        upper_layout.addWidget(self.op_list_widget)

        # Alt bölüm: İşlemleri düzenleme
        lower_layout = QtWidgets.QVBoxLayout()
        lbl = QtWidgets.QLabel("Arrange Operations:")
        lower_layout.addWidget(lbl)
        self.selected_op_list_widget = QtWidgets.QListWidget()
        lower_layout.addWidget(self.selected_op_list_widget)
        arrange_buttons_layout = QtWidgets.QHBoxLayout()
        btn_add_to_sequence = QtWidgets.QPushButton("Add to Sequence")
        btn_add_to_sequence.clicked.connect(self.add_to_sequence)
        btn_remove_from_sequence = QtWidgets.QPushButton("Remove from Sequence")
        btn_remove_from_sequence.clicked.connect(self.remove_from_sequence)
        btn_run = QtWidgets.QPushButton("Run Automation")
        btn_run.clicked.connect(self.run_automation)
        arrange_buttons_layout.addWidget(btn_add_to_sequence)
        arrange_buttons_layout.addWidget(btn_remove_from_sequence)
        arrange_buttons_layout.addWidget(btn_run)
        lower_layout.addLayout(arrange_buttons_layout)

        main_layout.addLayout(upper_layout)
        main_layout.addLayout(lower_layout)

        self.resize(800, 600)
        self.show()

    def start_scrcpy(self):
        self.scrcpy_process = QtCore.QProcess(self)
        scrcpy_command = [
            scrcpy_exe_path,
            "--prefer-text",
            "--window-title=scrcpy",
            "--always-on-top",
        ]
        self.scrcpy_process.start(scrcpy_command[0], scrcpy_command[1:])
        self.scrcpy_process.started.connect(self.position_windows)
        self.scrcpy_process.errorOccurred.connect(self.handle_scrcpy_error)

    def position_windows(self):
        try:
            import pygetwindow as gw

            time.sleep(1)
            scrcpy_windows = gw.getWindowsWithTitle("scrcpy")
            if not scrcpy_windows:
                raise Exception("Scrcpy window not found")
            scrcpy_window = scrcpy_windows[0]
            screen = QtWidgets.QApplication.desktop().screenGeometry()
            scrcpy_width = 400
            scrcpy_height = 800
            total_width = scrcpy_width + self.width() + 20
            scrcpy_x = (screen.width() - total_width) // 2
            scrcpy_y = (screen.height() - scrcpy_height) // 2
            scrcpy_window.resizeTo(scrcpy_width, scrcpy_height)
            scrcpy_window.moveTo(scrcpy_x, scrcpy_y)
            app_x = scrcpy_x + scrcpy_width + 20
            app_y = scrcpy_y
            self.move(app_x, app_y)
        except Exception as e:
            print(f"Failed to position windows: {e}")

    def handle_scrcpy_error(self, error):
        QtWidgets.QMessageBox.critical(
            self, "Error", f"Failed to start scrcpy: {error}"
        )

    def add_click(self):
        try:
            import pygetwindow as gw

            scrcpy_windows = gw.getWindowsWithTitle("scrcpy")
            if not scrcpy_windows:
                raise Exception("Scrcpy window not found")
            scrcpy_window = scrcpy_windows[0]
            scrcpy_x = scrcpy_window.left
            scrcpy_y = scrcpy_window.top
            scrcpy_width = scrcpy_window.width
            scrcpy_height = scrcpy_window.height
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self, "Error", f"Scrcpy window not found: {e}"
            )
            return

        # Create overlay
        self.overlay = OverlayWidget(scrcpy_x, scrcpy_y, scrcpy_width, scrcpy_height)
        self.overlay.clicked.connect(self.on_click_position)
        self.overlay.show()

    def on_click_position(self, x, y):
        self.overlay.close()
        name, clicks, duration = self.get_click_details()
        if name:
            op = Operation("click", name, x=x, y=y, clicks=clicks, duration=duration)
            self.operations.append(op)
            self.op_list_widget.addItem(
                f"Click: {name} ({x}, {y}), Clicks: {clicks}, Duration: {duration}s"
            )

    def get_click_details(self):
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Click Details")
        dialog.setWindowModality(QtCore.Qt.WindowModal)
        layout = QtWidgets.QFormLayout(dialog)
        name_edit = QtWidgets.QLineEdit()
        clicks_edit = QtWidgets.QLineEdit("1")
        duration_edit = QtWidgets.QLineEdit("0")
        layout.addRow("Name:", name_edit)
        layout.addRow("Number of clicks:", clicks_edit)
        layout.addRow("Duration (seconds):", duration_edit)
        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            dialog,
        )
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        dialog.setGeometry(self.geometry().adjusted(50, 50, -50, -50))
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            name = name_edit.text()
            if not name:
                QtWidgets.QMessageBox.critical(dialog, "Error", "Name cannot be empty.")
                return None, None, None
            try:
                clicks = int(clicks_edit.text())
                duration = float(duration_edit.text())
            except ValueError:
                QtWidgets.QMessageBox.critical(
                    dialog, "Error", "Invalid number of clicks or duration."
                )
                return None, None, None
            return name, clicks, duration
        else:
            return None, None, None

    def add_text(self):
        title, text = self.get_text_details()
        if title:
            op = Operation("write", title, text=text)
            self.operations.append(op)
            self.op_list_widget.addItem(f"Write Text: {title} - {text}")

    def get_text_details(self):
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Write Text")
        dialog.setWindowModality(QtCore.Qt.WindowModal)
        layout = QtWidgets.QFormLayout(dialog)
        title_edit = QtWidgets.QLineEdit()
        text_edit = QtWidgets.QLineEdit()
        layout.addRow("Title:", title_edit)
        layout.addRow("Text:", text_edit)
        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            dialog,
        )
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        dialog.setGeometry(self.geometry().adjusted(50, 50, -50, -50))
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            title = title_edit.text()
            text = text_edit.text()
            if not title or not text:
                QtWidgets.QMessageBox.critical(
                    dialog, "Error", "Title and Text cannot be empty."
                )
                return None, None
            return title, text
        else:
            return None, None

    def add_wait(self):
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Wait")
        dialog.setWindowModality(QtCore.Qt.WindowModal)
        layout = QtWidgets.QFormLayout(dialog)
        name_edit = QtWidgets.QLineEdit()
        duration_edit = QtWidgets.QLineEdit()
        layout.addRow("Name:", name_edit)
        layout.addRow("Duration (seconds):", duration_edit)
        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            dialog,
        )
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        dialog.setGeometry(self.geometry().adjusted(50, 50, -50, -50))
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            name = name_edit.text()
            if not name:
                QtWidgets.QMessageBox.critical(dialog, "Error", "Name cannot be empty.")
                return
            try:
                duration = float(duration_edit.text())
                if duration < 0:
                    raise ValueError
            except ValueError:
                QtWidgets.QMessageBox.critical(dialog, "Error", "Invalid duration.")
                return
            op = Operation("wait", name, duration=duration)
            self.operations.append(op)
            self.op_list_widget.addItem(f"Wait: {name}, Duration: {duration}s")

    def add_find(self):
        try:
            import pygetwindow as gw

            scrcpy_windows = gw.getWindowsWithTitle("scrcpy")
            if not scrcpy_windows:
                raise Exception("Scrcpy window not found")
            scrcpy_window = scrcpy_windows[0]
            scrcpy_x = scrcpy_window.left
            scrcpy_y = scrcpy_window.top
            scrcpy_width = scrcpy_window.width
            scrcpy_height = scrcpy_window.height
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self, "Error", f"Scrcpy window not found: {e}"
            )
            return

        # Seçim için overlay oluştur
        self.overlay = SelectionOverlay(scrcpy_x, scrcpy_y, scrcpy_width, scrcpy_height)
        self.overlay.selection_made.connect(self.on_selection_made)
        self.overlay.show()

    def on_selection_made(self, x, y, w, h, screenshot):
        self.overlay.close()
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Find Details")
        dialog.setWindowModality(QtCore.Qt.WindowModal)
        layout = QtWidgets.QFormLayout(dialog)
        name_edit = QtWidgets.QLineEdit()
        layout.addRow("Name:", name_edit)
        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            dialog,
        )
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        dialog.setGeometry(self.geometry().adjusted(50, 50, -50, -50))
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            name = name_edit.text()
            if not name:
                QtWidgets.QMessageBox.critical(dialog, "Error", "Name cannot be empty.")
                return
            template_path = f"templates/{name}.png"
            if not os.path.exists("templates"):
                os.makedirs("templates")
            cv2.imwrite(template_path, screenshot)
            op = Operation("find", name, template=template_path)
            self.operations.append(op)
            self.op_list_widget.addItem(f"Find: {name}")
        else:
            return

    def add_to_sequence(self):
        selected_items = self.op_list_widget.selectedItems()
        for item in selected_items:
            index = self.op_list_widget.row(item)
            op = self.operations[index]
            self.selected_operations.append(op)
            self.selected_op_list_widget.addItem(item.text())

    def remove_from_sequence(self):
        selected_items = self.selected_op_list_widget.selectedItems()
        for item in selected_items:
            index = self.selected_op_list_widget.row(item)
            self.selected_operations.pop(index)
            self.selected_op_list_widget.takeItem(index)

    def run_automation(self):
        try:
            import pygetwindow as gw

            scrcpy_windows = gw.getWindowsWithTitle("scrcpy")
            if not scrcpy_windows:
                raise Exception("Scrcpy window not found")
            scrcpy_window = scrcpy_windows[0]
            scrcpy_x = scrcpy_window.left
            scrcpy_y = scrcpy_window.top
            scrcpy_width = scrcpy_window.width
            scrcpy_height = scrcpy_window.height
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self, "Error", f"Scrcpy window not found: {e}"
            )
            return

        for op in self.selected_operations:
            if op.type == "click":
                # Tıklama işlemi
                x, y = op.params["x"], op.params["y"]
                clicks = op.params.get("clicks", 1)
                duration = op.params.get("duration", 0)
                interval = duration / clicks if clicks > 0 else duration
                pyautogui.click(
                    x=scrcpy_x + x,
                    y=scrcpy_y + y,
                    clicks=clicks,
                    interval=interval,
                )
                time.sleep(0.5)
            elif op.type == "write":
                # Yazı yazma işlemi
                text = op.params["text"]
                scrcpy_window.activate()
                time.sleep(0.1)
                pyautogui.click(scrcpy_x + 10, scrcpy_y + 10)
                time.sleep(0.1)
                pyautogui.typewrite(text, interval=0.1)
                time.sleep(0.5)
            elif op.type == "wait":
                # Bekleme işlemi
                duration = op.params["duration"]
                time.sleep(duration)
            elif op.type == "find":
                # Bulma işlemi
                template_path = op.params["template"]
                if not os.path.exists(template_path):
                    QtWidgets.QMessageBox.critical(
                        self, "Error", f"Template image not found: {template_path}"
                    )
                    continue
                screenshot = pyautogui.screenshot(
                    region=(scrcpy_x, scrcpy_y, scrcpy_width, scrcpy_height)
                )
                screenshot = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
                template = cv2.imread(template_path)
                res = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)
                threshold = 0.8
                loc = np.where(res >= threshold)
                if len(loc[0]) > 0:
                    pt = (loc[1][0], loc[0][0])
                    pyautogui.click(
                        scrcpy_x + pt[0] + template.shape[1] // 2,
                        scrcpy_y + pt[1] + template.shape[0] // 2,
                    )
                else:
                    QtWidgets.QMessageBox.warning(
                        self, "Warning", f"Template {op.name} not found on screen."
                    )

    def save_automation(self):
        title, ok = QtWidgets.QInputDialog.getText(self, "Save Automation", "Title:")
        if ok and title:
            options = QtWidgets.QFileDialog.Options()
            filename, _ = QtWidgets.QFileDialog.getSaveFileName(
                self,
                "Save Automation",
                title + ".json",
                "JSON Files (*.json)",
                options=options,
            )
            if filename:
                data = [op.__dict__ for op in self.selected_operations]
                with open(filename, "w") as f:
                    json.dump(data, f)
                QtWidgets.QMessageBox.information(
                    self, "Success", "Automation saved successfully."
                )

    def load_automation(self):
        options = QtWidgets.QFileDialog.Options()
        filename, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "Load Automation", "", "JSON Files (*.json)", options=options
        )
        if filename:
            with open(filename, "r") as f:
                data = json.load(f)
            self.selected_operations = []
            self.selected_op_list_widget.clear()
            for op_data in data:
                op = Operation(op_data["type"], op_data["name"], **op_data["params"])
                self.selected_operations.append(op)
                if op.type == "click":
                    self.selected_op_list_widget.addItem(
                        f"Click: {op.name} ({op.params['x']}, {op.params['y']}), Clicks: {op.params['clicks']}, Duration: {op.params['duration']}s"
                    )
                elif op.type == "write":
                    self.selected_op_list_widget.addItem(
                        f"Write Text: {op.name} - {op.params['text']}"
                    )

    def closeEvent(self, event):
        if self.scrcpy_process:
            self.scrcpy_process.kill()
            self.scrcpy_process.waitForFinished()
        event.accept()


class OverlayWidget(QtWidgets.QWidget):
    clicked = QtCore.pyqtSignal(int, int)

    def __init__(self, x, y, width, height):
        super().__init__(None)
        self.setWindowFlags(
            QtCore.Qt.WindowStaysOnTopHint | QtCore.Qt.FramelessWindowHint
        )
        self.setAttribute(QtCore.Qt.WA_TransparentForMouseEvents, False)
        self.setWindowOpacity(0.3)
        self.setGeometry(x, y, width, height)
        self.setCursor(QtCore.Qt.BlankCursor)
        self.crosshair_size = 20
        self.crosshair_color = QtGui.QColor("red")
        self.setMouseTracking(True)
        self.cursor_pos = QtCore.QPoint(width // 2, height // 2)

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setPen(QtGui.QPen(self.crosshair_color, 2))
        x = self.cursor_pos.x()
        y = self.cursor_pos.y()
        painter.drawLine(x - self.crosshair_size, y, x + self.crosshair_size, y)
        painter.drawLine(x, y - self.crosshair_size, x, y + self.crosshair_size)

    def mouseMoveEvent(self, event):
        self.cursor_pos = event.pos()
        self.update()

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            self.clicked.emit(event.x(), event.y())


class SelectionOverlay(QtWidgets.QWidget):
    selection_made = QtCore.pyqtSignal(int, int, int, int, np.ndarray)

    def __init__(self, x, y, width, height):
        super().__init__(None)
        self.setWindowFlags(
            QtCore.Qt.WindowStaysOnTopHint | QtCore.Qt.FramelessWindowHint
        )
        self.setAttribute(QtCore.Qt.WA_TransparentForMouseEvents, False)
        self.setWindowOpacity(0.3)
        self.setGeometry(x, y, width, height)
        self.setCursor(QtCore.Qt.CrossCursor)
        self.start_pos = None
        self.end_pos = None
        self.rect = None

    def mousePressEvent(self, event):
        self.start_pos = event.pos()
        self.rect = QtCore.QRect()

    def mouseMoveEvent(self, event):
        self.end_pos = event.pos()
        self.rect = QtCore.QRect(self.start_pos, self.end_pos)
        self.update()

    def mouseReleaseEvent(self, event):
        self.end_pos = event.pos()
        self.rect = QtCore.QRect(self.start_pos, self.end_pos)
        x = self.rect.left()
        y = self.rect.top()
        w = self.rect.width()
        h = self.rect.height()
        if w > 0 and h > 0:
            screenshot = pyautogui.screenshot(region=(self.x() + x, self.y() + y, w, h))
            screenshot = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
            self.selection_made.emit(x, y, w, h, screenshot)
        self.close()

    def paintEvent(self, event):
        if self.rect:
            painter = QtGui.QPainter(self)
            painter.setPen(QtGui.QPen(QtGui.QColor("red"), 2))
            painter.drawRect(self.rect.normalized())


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    ex = App()
    sys.exit(app.exec_())

